!SESSION 2023-11-15 09:13:09.424 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file D:\workspace_java7\.metadata\.bak_1.log
Created Time: 2023-11-15 09:48:58.477

!ENTRY org.eclipse.jdt.ui 4 0 2023-11-15 09:48:58.477
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:48:58.484
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (num1, num2) -> { (num1 >= num2) ? num1 : num2 };
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-11-15 09:48:58.484
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-11-15 09:48:58.484
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:49:00.825
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (num1, num2) -> { (num1 >= num2) ? num1 : num2 };
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-11-15 09:49:00.826
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-11-15 09:49:00.827
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:49:04.400
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (num1, num2) -> { (num1 >= num2) ? num1 : num2 };
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-11-15 09:49:04.400
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-11-15 09:49:04.400
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:06.732
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (num1, num2) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-11-15 09:55:06.733
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-11-15 09:55:06.734
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:07.094
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (num1, num2) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-11-15 09:55:07.095
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-11-15 09:55:07.095
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:08.999
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (num1, num2) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-11-15 09:55:08.999
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-11-15 09:55:09.000
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:09.005
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (num1, num2) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-11-15 09:55:09.005
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-11-15 09:55:09.005
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:09.947
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (num1, num2) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-11-15 09:55:09.947
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-11-15 09:55:09.947
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:09.951
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (num1, num2) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-11-15 09:55:09.952
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:10.054
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (num1, num2) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-11-15 09:55:10.055
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-11-15 09:55:10.055
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:11.199
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (x, num2) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-11-15 09:55:11.199
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-11-15 09:55:11.199
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:11.206
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (x, num2) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-11-15 09:55:11.206
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-11-15 09:55:11.207
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:11.209
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (x, num2) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-11-15 09:55:11.209
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:11.341
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (x, num2) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-11-15 09:55:11.342
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-11-15 09:55:11.342
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:12.870
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (x, ) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-11-15 09:55:12.871
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-11-15 09:55:12.871
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:12.979
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (x, ) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-11-15 09:55:12.980
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-11-15 09:55:12.980
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:13.518
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (x, y) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-11-15 09:55:13.518
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-11-15 09:55:13.518
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:13.611
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (x, y) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-11-15 09:55:13.612
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-11-15 09:55:13.612
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:14.880
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (x, y) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-11-15 09:55:14.880
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-11-15 09:55:14.880
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-11-15 09:55:17.552
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package lambda;

public class Ex1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 람다식(Lambda Expressions)
		 * - 자바 8에 추가된 가장 큰 특징
		 * - "함수형" 프로그래밍 형태를 받아들인 결과
		 * 
		 * 함수형 프로그램이란? (함수형 vs 객체지향)
		 * - 함수형 : 1950년대, 객체지향 : 1990년대 (역사가 더 오래되었음)
		 * - 기능 위주의 프로그래밍 기법
		 * - 매개변수만을 사용하여 만드는 함수(순수 함수, pure function) 를
		 * 	구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식
		 * - 객체 지향 : 객체를 기반으로 구현, 클래스에 속성과 기능을 정의
		 * 	함수형 : 함수를 기반으로 자료를 입력받아 구현, 기능 즉 함수가 따로 존재
		 * 
		 * - 함수 이름이 없는 익명 함수를 만드는 것
		 * 	메서드의 이름과 리턴타입을 빼고 '->' 를 활용하여 람다식을 구현
		 * 	ex) public int add(int x, int y) {
		 * 			return x + y;
		 * 		}
		 * 		의 메서드를 람다식으로 표현하면
		 * 		(int x, int y) -> { return x + y; }
		 * 
		 * < 람다식의 기본 문법 >
		 * (데이터타입 매개변수, ...) -> { 실행문, ... }
		 * 
		 * 1. 기본형
		 * (int x) -> { System.out.println(x); }
		 * 
		 * 2. 매개변수의 타입을 추론할 수 있는 경우에는 타입 생략 가능
		 * (x) -> { System.out.println(x); }
		 * 
		 * 3. 매개변수나 실행문이 하나라면 소괄호()와 중괄호{} 를 생략할 수 있음
		 * 	(이 때 세미콜론은 생략한다)
		 * x -> System.out.println(x)
		 * 주의! 매개변수가 두 개 이상인 경우 소괄호()를 생략할 수 없다
		 * 
		 * 4. 매개변수가 없을 경우 소괄호() 를 사용한다 (생략 불가)
		 * () -> System.out.println(x)
		 * 
		 * 5. 리턴이 필요한 경우 return 키워드를 사용
		 * (x, y) -> { return x + y; }
		 * 주의! return 문은 중괄호를 생략할 수 없다
		 * 
		 * 6. 실행문이 단순히 return 문 하나로 표현되는 경우
		 * 	표현식만 사용할 수 있으며, 이 때 리턴 값은 표현식의 결과값이 됨
		 * 	주의! 이때 세미콜론을 붙이지 않는다
		 * (x, y) -> x + y
		 */
		
		MaxPrintNumber mpn = new MaxPrintNumber();
		System.out.println(mpn.maxNum(10, 20));
		
		MyNumber max = new MyNumberClass();
		System.out.println(max.getMax(10, 20));
		
		System.out.println("-------------------------------------------------");
		
		MyNumber max2 = (x, y) -> { (num1 >= num2) ? num1 : num2 };
		
		
		
	}
}

class MaxPrintNumber {
	public int maxNum(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}
}

// ========================================================================================
// MyNumber 인터페이스를 구현한 MyNumberClass 정의
interface MyNumber {
	int getMax(int num1, int num2);
}

class MyNumberClass implements MyNumber{

	@Override
	public int getMax(int num1, int num2) {
		if(num1 >= num2) {
			return num1;			
		} else {
			return num2;
		}
	}	
}

// 위의 getMax() 메서드를 람다식으로 표현하기 위해
// 함수형 인터페이스 선언한다.
// => 자바에서는 참조 변수 없이 메서드를 호출할 수 없음
// => 람다식을 구현하기 위해 함수형 인터페이스를 만들고,
//		인터페이스에 람다식으로 구현할 메서드를 선언하는 형태로 사용
// => 주의! 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하므로
// 인터페이스가 두 개 이상의 메서드를 가지면 안된다
@FunctionalInterface // 함수형 인터페이스 용도로 사용됨을 알림
interface MyNumber2 {
	int getMax(int num1, int num2);
//	int add(int num1, int num2);
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-11-15 09:55:17.553
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-11-15 09:55:17.553
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2560)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2068)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1736)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2056)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3986)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:4066)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:561)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-11-20 09:21:46.246 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2023-11-20 09:22:08.430
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-11-20 09:22:08.430
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5b11d0d8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5cf39df6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-11-20 09:22:08.430
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@46ae897c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@44846c76,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-11-20 09:22:14.821
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITWILL'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-11-20 10:12:57.260 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2023-11-20 10:13:00.137
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-11-20 10:13:00.137
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@12e13abd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5694f6a0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-11-20 10:13:00.137
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6e0dec27,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3857c5d5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-11-20 10:13:02.476
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITWILL'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-11-28 08:43:36.414 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2023-11-28 08:43:59.028
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-11-28 08:43:59.028
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@237824b0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@52a8f789,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-11-28 08:43:59.028
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5345552f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@55ba4bff,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-11-28 08:44:05.611
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITWILL'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-11-28 12:22:28.005 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.jface 2 0 2023-11-28 12:22:44.403
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-11-28 12:22:44.403
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3705a85c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2284058a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-11-28 12:22:44.403
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5b11d0d8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5cf39df6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-11-28 12:22:47.730
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITWILL'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
